\documentclass[a4paper, 12pt]{article}

\newcommand{\templates}{../../template}
\input{\templates/style}
\input{\templates/front_page}
\input{\templates/history}

\settitolo{Motivazione delle Scelte}
\setprogetto{Lumos Minima}
\setcommittenti{Imola Informatica}
\setredattori{Ceccato Francesco \\ Soldà Matteo}
\setdestuso{esterno}
\setdescrizione{
Questo documento riporta i confronti tra i vari linguaggi presi in considerazione per lo sviluppo del progetto e la motivazione della scelta di uno rispetto agli altri.
}

\addversione{0.0.0}{09/05/2023}{Soldà Matteo}{Ceccato Francesco}{Prima stesura.}
\addversione{0.0.1}{18/05/2023}{Soldà Matteo}{}{Aggiunta decisione preliminare dei linguaggi e framework}


\begin{document}
\makeindexdetails
\makefrontpage \makeversioni
\tableofcontents
\newpage
\clearpage
\makecontentsdetails{Motivazione delle Scelte}
\newpage
\section{Introduzione}
Il seguente documento ha come scopo principale quello di confrontare i vari linguaggi, database e framework con lo scopo di fornire un prodotto quanto più efficace, efficiente e aderente alle richieste del proponente.\\
\subsection{Sitografia}
\begin{itemize}
    \item https://www.quora.com/Why-are-there-so-many-backend-systems-written-in-dynamically-typed-languages-while-the-benefit-of-static-typing-is-obvious;
    \item https://mobisoftinfotech.com/resources/blog/typescript-vs-javascript/;
    \item https://stackoverflow.com/questions/49640121/mixing-javascript-and-typescript-in-node-js;
    \item https://www.monocubed.com/blog/top-python-frameworks/;
    \item https://www.theserverside.com/tip/The-differences-between-Java-and-TypeScript-devs-must-know;
    \item https://medium.com/rewrite-tech/embedding-typescript-in-java-a343576031be;
    \item https://blog.geekandjob.com/framework-javascript/.
\end{itemize}

\newpage
\section{Confronti}
\subsection{Database}
Come database, non sapendo al momento come saranno strutturati i dati che necessitano di essere salvati in maniera persistente, abbiamo preso in considerazione \href{https://mariadb.org/}{MariaDB} per i database SQL e \href{https://www.mongodb.com/}{MongoDB} per i database NoSQL. \\
Queste due scelte sono state fatte per due motivi principali:
\begin{itemize}
    \item Ricerca di un database computazionalmente leggero e che fosse aderente agli standard;
    \item Ricerca di un database la cui community è attiva e la documentazione chiara e puntuale, così da poter risolvere quanto prima i problemi che si potessero presentare data la poca esperienza accumulata con i database nel tempo.
\end{itemize}
\subsection{Backend}
Per quanto riguarda il backend, la scelta sarà vincolata dalla preferenza verso un linguaggio staticamente o dinamicamente tipizzato. \\
Qualora si scegliesse la tipizzazione statica, le scelte ricadono su:
\begin{itemize}
    \item \href{https://www.java.com/it/}{Java};
    \item \href{https://learn.microsoft.com/en-us/dotnet/csharp/}{C\#};
    \item \href{https://www.typescriptlang.org/}{TypeScript}.
\end{itemize}
Mentre, scegliendo la tipizzazione dinamica, le scelte ricadrebbero su:
\begin{itemize}
    \item \href{https://www.python.org/}{Python};
    \item \href{https://www.javascript.com/}{JavaScript}.
\end{itemize}
\subsubsection{C\#}
\textbf{Pro:}
\begin{itemize}
    \item Facile da eseguire su dispositivi Windows (che rappresenta la stragrande maggioranza degli utenti);
    \item Essendo un linguaggio compilato e non interpretato, rende difficile in caso di attacchi la lettura del codice sorgente in chiaro.
\end{itemize}
\vspace*{0.5cm}
\textbf{Contro:}
\begin{itemize}
    \item Deve essere ricompilato per ogni minima modifica;
    \item Hostabile solo su server Windows.
\end{itemize}

\subsubsection{Java}
\textbf{Pro:}
\begin{itemize}
    \item Linguaggio facile da imparare;
    \item Linguaggio di alto livello (assenza di puntatori, presenza di garbage collector);
    \item Linguaggio OOP;
    \item \textit{Platform Indipendent};
    \item Supporto al \textit{multithreading\textsubscript{G}}. 
\end{itemize}
\vspace*{0.5cm}
\textbf{Contro:}
\begin{itemize}
    \item Rispetto ad altri linguaggi può risultare più lento o povero in fatto di performance;
    \item Mancanza di feature per il backup dei dati;
    \item Rispetto ad altri linguaggi, richiede uno spazio di memoria significativo;
    \item Rispetto ad altri linguaggi, usa molto più codice per svolgere una operazione basilare.
\end{itemize}
\subsubsection{JavaScript}
\textbf{Pro:}
\begin{itemize}
    \item Semplice da imparare;
    \item Interoperabile;
    \item Versatile in quanto linguaggio \textit{fullstack\textsubscript{G}}.
\end{itemize}
\vspace*{0.5cm}
\textbf{Contro:}
\begin{itemize}
    \item Linguaggio interpretato;
    \item Tipizzazione dinamica;
    \item Inconsistenza tra browser.
\end{itemize}
\subsubsection{Python}
\textbf{Pro:}
\begin{itemize}
    \item Facile da imparare;
    \item Flessibile ed estensibile;
    \item Presenza di moltissime librerie;
    \item Estremamente scalabile;
    \item Portabile;
    \item Vasta integrazione con l'\textit{IoT\textsubscript{G}}.
\end{itemize}
\vspace*{0.5cm}
\textbf{Contro:}
\begin{itemize}
    \item Forte utilizzo di memoria;
    \item Tipizzazione dinamica;
    \item Multithreading complesso;
    \item Garbace collection che porta ad un potenziale spreco di memoria.
\end{itemize}
\subsubsection{Typescript}
\textbf{Pro:}
\begin{itemize}
    \item Linguaggio compilato;
    \item Tipizzazione statica.
\end{itemize}
\vspace*{0.5cm}
\textbf{Contro:}
\begin{itemize}
    \item Inconsistenza tra browser;
    \item Tipizzazione alcune volte complessa;
    \item Necessità di ricompilare per ogni minima modifica.
\end{itemize}
\subsection{Backend Framework}
\subsubsection{C\#}
\begin{itemize}
    \item \href{https://dotnet.microsoft.com/en-us/apps/aspnet}{ASP.NET}.
\end{itemize}
\subsubsection{Java}
\begin{itemize}
    \item \href{https://spring.io/}{Java Spring}.
\end{itemize}
\subsubsection{JavaScript}
\begin{itemize}
    \item \href{https://nextjs.org/}{Next};
    \item \href{https://nodejs.org/}{Node}.
\end{itemize}
\subsubsection{Python}
\begin{itemize}
    \item \href{https://www.djangoproject.com/}{Django};
    \item \href{https://flask.palletsprojects.com/}{Flask}.
\end{itemize}
\subsubsection{Typescript}
\begin{itemize}
    \item \href{https://nestjs.com/}{Nest};
    \item \href{https://feathersjs.com/}{Feathers};
    \item \href{https://loopback.io/}{Loopback}.
\end{itemize}
\subsection{Frontend}
Escludendo \textit{HTML5}, \textit{XHTML} e \textit{CSS} che saranno di sicuro usati per la parte di frontend della webapp, i linguaggi tra cui scegliere risultano essere solamente
\begin{itemize}
    \item \href{https://www.typescriptlang.org/}{TypeScript};
    \item \href{https://www.javascript.com/}{JavaScript}.
\end{itemize}
\subsubsection{JavaScript}
\subsubsection{TypeScript}

\subsection{Frontend Framework}
\subsubsection{JavaScript}
\begin{itemize}
    \item \href{https://angularjs.org/}{Angular};
    \item \href{https://react.dev/}{React};
    \item \href{https://vuejs.org/}{Vue};
    \item \href{https://backbonejs.org/}{Backbone};
    \item \href{https://preactjs.com/}{Preact};
    \item \href{https://expressjs.com/}{Express}.
\end{itemize}
\subsubsection{TypeScript}
\begin{itemize}
    \item \href{https://angularjs.org/}{Angular};
    \item \href{https://emberjs.com/}{Ember}.
\end{itemize}
Per i pro e i contro dei framework, sia frontend che backend, si rimanda il lettore a \href{https://blog.geekandjob.com/framework-javascript/}{questo link}.
\newpage
\section{Scelte e Motivazioni}
A seguito di una votazione unanime del gruppo, si è pensato di utilizzare il framework \href{https://react.dev/}{React} per il frontend e il framework \href{https://nodejs.org/}{Node} per il backend, entrambi utilizzeranno \href{https://www.typescriptlang.org/}{TypeScript} insieme a \href{https://www.typescriptlang.org/docs/handbook/jsx.html}{JSX}.
Queste scelte sono dovute a diversi fattori, nello specifico:
\begin{itemize}
    \item Si è scelto TypeScript al posto di JavaScript in quanto utilizza una tipizzazione statica e non dinamica, portando di conseguenza i seguenti vantaggi:
    \begin{itemize}
        \item Rilevazione degli errori a tempo di compilazione: nei linguaggi a tipizzazione statica, gli errori di tipo vengono rilevati durante la fase di compilazione; ciò significa che gli errori di tipo, come l'uso di un tipo errato di dato o la mancanza di coerenza tra i tipi, vengono evidenziati prima che il programma venga eseguito. Questo aiuta a prevenire errori costosi o bug difficili da individuare in fase di esecuzione;
        \item Maggiore robustezza e sicurezza: la dichiarazione esplicita dei tipi di dati può aiutare gli sviluppatori a comprendere meglio l'intento del codice e a individuare eventuali incongruenze o problemi potenziali. Inoltre, poiché i tipi sono controllati a tempo di compilazione, i programmi tipizzati staticamente tendono ad avere meno errori di tipo durante l'esecuzione;
        \item Ottimizzazione delle performance: i linguaggi tipizzati staticamente possono spesso beneficiare di ottimizzazioni a livello di compilazione. Il compilatore può effettuare analisi statiche più avanzate, come l'inferenza di tipo o la rilevazione di pattern specifici, per generare codice più efficiente. Di conseguenza, i programmi tipizzati staticamente possono ottenere migliori prestazioni rispetto ai programmi tipizzati dinamicamente;
        \item Documentazione implicita: nei linguaggi con tipizzazione statica, i tipi di dati possono fungere da documentazione implicita del codice. La dichiarazione esplicita dei tipi di dati aiuta gli sviluppatori a capire come utilizzare correttamente le funzioni e le variabili, migliorando la leggibilità e la manutenibilità del codice;
        \item Semplicità nella collaborazione e per la scalabilità: nei progetti di grandi dimensioni o quando si lavora in team, la tipizzazione statica può favorire una migliore collaborazione. La dichiarazione dei tipi rende più chiaro come le diverse parti del sistema interagiscono tra loro, facilitando l'integrazione del codice scritto da più persone. Inoltre, la tipizzazione statica può aiutare a identificare e prevenire errori di integrazione durante il processo di sviluppo e di manutenzione del software.
    \end{itemize}
    \item Si è scelto di utilizzare React e NodeJS in quanto consigliati dall'azienda proponente, rendendo quindi possibile la comunicazione con la stessa per la risoluzione di problemi di qualsiasi entità dovuta alla poca conoscenza dei framework, inoltre:
    \begin{itemize}
        \item React è stato scelto per i seguenti motivi:
        \begin{itemize}
            \item Component-based architecture: utilizza un'architettura basata su componenti, che consente di suddividere l'interfaccia utente in componenti modulari e riutilizzabili. Questo approccio favorisce la modularità del codice, semplifica la gestione dello stato e offre una maggiore scalabilità del progetto;
            \item Virtual DOM: utilizza un concetto chiamato "Virtual DOM" (DOM virtuale). Questo significa che React mantiene una rappresentazione leggera del DOM in memoria e si occupa di aggiornare solo le parti dell'interfaccia utente che sono state effettivamente modificate. Questo approccio porta a un'efficienza notevole nelle operazioni di rendering e aggiornamento dell'interfaccia utente, migliorando le prestazioni complessive dell'applicazione;
            \item Reattività e gestione dello stato: fornisce un'eccellente gestione dello stato dell'applicazione. Attraverso il concetto di "state" (stato) e "props" (proprietà), è possibile gestire in modo semplice e prevedibile i dati dell'applicazione e reagire ai cambiamenti in modo efficiente. Inoltre, React offre un'ampia gamma di librerie e soluzioni per la gestione dello stato, come Redux e MobX, che semplificano ulteriormente la gestione delle informazioni in un'applicazione complessa;
            \item Ampia comunità e supporto: ha una delle comunità di sviluppatori più grandi e attive nel panorama dello sviluppo frontend. Ciò significa che è possibile trovare una vasta gamma di risorse, documentazione, tutorial e librerie di terze parti per supportare lo sviluppo di progetti. Inoltre, la comunità offre costantemente aggiornamenti, nuove funzionalità e correzioni di bug per React, garantendo che il framework sia all'avanguardia;
            \item Ecosistema ricco: è supportato da un vasto ecosistema di strumenti e librerie. Ci sono numerose librerie, come React Router per il routing, Axios per le richieste HTTP e molti altri che semplificano lo sviluppo di funzionalità specifiche;
            \item Compatibilità con TypeScript: ha un'ottima integrazione con TypeScript, un linguaggio di programmazione con tipizzazione statica. Utilizzando React con TypeScript, puoi ottenere i benefici della tipizzazione statica, come rilevazione degli errori a tempo di compilazione e autocompletamento, per una migliore esperienza di sviluppo e una maggiore sicurezza del codice.
        \end{itemize}
        \item NodeJS è stato scelto per i seguenti motivi:
        \begin{itemize}
            \item Efficienza e scalabilità: è noto per la sua efficienza e scalabilità. Grazie al suo modello di I/O non bloccante e orientato agli eventi, Node.js può gestire un grande numero di richieste simultanee con una risposta rapida. Ciò lo rende particolarmente adatto per applicazioni in tempo reale e applicazioni con un alto traffico;
            \item Comunità e supporto: ha una comunità di sviluppatori attiva e una vasta quantità di risorse disponibili. Ciò significa che si può trovare un supporto significativo, documentazione, tutorial e librerie di terze parti a supporto delle difficoltà che si potrebbero incontrare;
            \item Adattabilità: è un runtime flessibile che può essere utilizzato per diversi tipi di progetti. Può essere utilizzato per sviluppare API RESTful, servizi web, applicazioni in tempo reale, microservizi e molto altro ancora. La sua natura leggera e modulare consente di adattarlo alle specifiche esigenze del tuo progetto.
        \end{itemize}
    \end{itemize}
\end{itemize}
\vspace*{0.5cm}
Per far funzionare ReactJS e NodeJS con TypeScript, è necessario configurare correttamente l'ambiente di sviluppo.\\
Prima di tutto, è necessario creare un nuovo progetto e impostare le dipendenze necessarie.\\ \\
Per un'applicazione ReactJS, puoi utilizzare Create React App (CRA) per avviare rapidamente un progetto preconfigurato che supporta TypeScript di default, quindi non è necessaria alcuna configurazione aggiuntiva.\\ \\
Per un'applicazione NodeJS, si può inizializzare un nuovo progetto utilizzando \textit{npm} o \textit{yarn} e installare le dipendenze necessarie, come \textit{Express} per il routing e \textit{Mongoose} per l'interazione con il database. \\
Bisogna inoltre assicurarsi di configurare il progetto per utilizzare TypeScript impostando un file di configurazione \texttt{tsconfig.json} nella radice del progetto.\\\\
Successivamente, si possono aggiungere le definizioni dei tipi necessarie per ReactJS e le dipendenze specifiche che si utilizzando in NodeJS. Per ReactJS, bisogna installare le definizioni dei tipi per React tramite il pacchetto \texttt{@types/react}. Per le applicazioni NodeJS, bisogna installare le definizioni dei tipi per le dipendenze specifiche utilizzate nel progetto.\\
\end{document} 

